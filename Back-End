// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract subsidyBackend {
    // Global variable to store central government schemes:
    uint256 public centralGovSchemes = 100000000;
    uint256 public BetiBachaoBetiPadhao = 10000000;
    uint256 public standUpIndiaScheme = 100000000;
    uint256 public ayushManBharat = 100000000;
    uint256 public PMKISAN = 10000000;
    uint public constant BBBP = 1300;
    uint public constant SUIS = 1600;
    uint public constant AMB = 2000;
    uint public constant PMK = 5000;
    uint256 public totalBeneficiaries = 0;
    uint256 public constant SCALE = 10**18;
    uint public FinalId = 0;
    // uint[] public adhaarNumbers;
    // Variable to store amount each distributor recieves.its
    // better to use mapping along with a function here, we can store
    // each distributors address along with a necessary fund
    mapping(uint256 => uint256) public distributedFunds;
    // I am mapping integer to integer: Logic-> each distributor will have a unique id with a balance associated wtih it
    mapping(uint256 => uint256) public distributorWeight;
    // this map is used to identify how much funds each distributor will recieve
    mapping(uint256 => uint256[]) public distributorToBeneficiary;
    // This is to map each distributor to a beneficiary
    mapping(uint256 => bool) public beneficiary;
    // mapping(uint256 => bool) public beneficiarySUIS;
    // mapping(uint256 => bool) public beneficiaryAMB;
    // mapping(uint256 => bool) public beneficiaryPMK;
    // This is to check if a distributor gets his funds
    mapping(uint256 => bool) public beneficiaryPresence;
    // This is to map each beneficiary to his related scheme
    mapping(uint256 => uint) public beneficiaryScheme; // {1 for BBBP, 2 for SIS, 3 for AMB, 4 for PMKISAN};
    // This is to check if a beneficiary can recieve money online.
    // -------------------------------------------------------------
    // in all the functions below we are just updating the variables
    // -------------------------------------------------------------
    // Function for government to send money to distributor
    // One thing we have to consider is how much money each distributor
    // recieves, this can be calculated using mapping distributorToBeneficiary
    // and a global variable totalBeneficiaries
    // we can use math to do that take the fraction of number of beneficiary
    // to that particular distributor to the total number of beneficiaries
    // and multiply it with centralGovSchemes and update it with the map distributor weight
    function CentralToDistributor(uint256 distributorId,uint scheme) public  {
        uint256 weight = (distributorWeight[distributorId] * SCALE) / totalBeneficiaries*scheme;
        scheme-=weight;
        distributedFunds[distributorId] = weight;
        FinalId+=1;
    }
    // ==============================================================
    // Before allocation funds to every distributor we should know the number of beneficiary each guy holds
    // we can maintain the state using the mapping distributor weight

    function AddBeneficiary(uint256 distributorId, uint256 beneficiaryAdhaar, bool presentOnline,uint schemeType)
        public
    {
        // we can update both distributor weight and distributorToBeneficiary mappings over here
        // and also check if the beneficiary can recieve the grants through online mediums
        totalBeneficiaries+=1;
        distributorWeight[distributorId] += 1;
        distributorToBeneficiary[distributorId].push(beneficiaryAdhaar);
        beneficiaryPresence[distributorId] = presentOnline;
        beneficiaryScheme[beneficiaryAdhaar] = schemeType;
    }
    // ---------------------------------------------------------------------------------
    // This is to check the distribution status of the distributor
    function distributorFunds(
        uint256 distributorId,
        uint256 associatedBeneficiaries,
        uint256 schemeBenefit
    ) public {
        if(beneficiaryPresence[associatedBeneficiaries]){
            distributedFunds[distributorId] -= schemeBenefit;
            // Let 1000 be the basic subsidy amount for now
            beneficiary[associatedBeneficiaries] = true;
        }
        // I am going to handle offline distributor outside of this function
    }
    // ----------------------------------------------------------------------------------
    // Function for handling offline distribution of funds,
    // My logic here would be making a separate portal for the distributor from where he can log in the 
    // blockchain whenever he distributes the funds
    // Event declaration
    event OfflineDistribution(
        address indexed distributor, 
        uint256 distributorId, 
        uint256 associatedBeneficiary
    );
    // Function to handle offline subsidy distribution
    function offlineDistribution(uint256 distributorId, uint256 associatedBeneficiary) public {
        require(!beneficiary[associatedBeneficiary], "Beneficiary has already claimed the funds");
        beneficiary[associatedBeneficiary] = true;
        emit OfflineDistribution(msg.sender, distributorId, associatedBeneficiary);
    }
    // This event is for the beneficiary to check status of his scheme
    event CheckStatus(
        address indexed beneficiaryAddress, 
        uint256 associatedBeneficiary, 
        string statement
    );
    // Function to check the status of a beneficiary's scheme
    function checkStatus(uint256 associatedBeneficiaries) public {
        if(beneficiary[associatedBeneficiaries]){
            emit CheckStatus(msg.sender, associatedBeneficiaries, "Your subsidy has been claimed");
        }
        else{
            emit CheckStatus(msg.sender,associatedBeneficiaries, "Your subsidy has'nt been claimed yet");
        }
    }
}
